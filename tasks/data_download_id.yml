---

# Bypass download automation prevention
- name: Load Nessus Agent download page.
  local_action:
    module: get_url
    url: "{{ nessus_download_page }}"
    dest: "{{ nessus_linux_tmp }}/nessus_download.html"
    force: yes
  become: false

# The Nessus download page has invalid XML that xpath won't parse.
# This narrows to just the timecheck line we care about.
- name: Grep download-modal-link line and make a single line file with it.
  local_action:
    module: "shell grep download-modal-link {{ nessus_linux_tmp }}/nessus_download.html | grep '{{ data_file_name }}' | sed 's/.* data-download-id=\"\\([0-9]*\\)\".*/\\1/'"
  become: false
  register: nessus_download_id
  ignore_errors: "{{ ansible_check_mode }}"

- debug:
    var: nessus_download_id

# The Nessus download page has invalid XML that xpath won't parse.
# This narrows to just the timecheck line we care about.
- name: Grep download-modal-link line and make a single line file with it.
  local_action:
    module: "shell grep csrf-token {{ nessus_linux_tmp }}/nessus_download.html | sed 's/.* content=\"\\(.*?\\)\".*/\\1/'"
  become: false
  register: nessus_csrf_token
  ignore_errors: "{{ ansible_check_mode }}"

- debug:
    var: nessus_csrf_token

- name: Get tokenized download URL.
  uri:
    url: "https://www.tenable.com/downloads/pages/61/downloads/{{ nessus_download_id.stdout }}/download_file"
    method: POST
    body_format: form-urlencoded
    follow_redirects: none
    status_code: 302
    headers:
      Referer: https://www.tenable.com/downloads/nessus-agents
    body:
      _method: get_download_file
      authenticity_token: "{{ nessus_csrf_token.stdout }}"
      commit: "I+Agree"
      i_agree_to_tenable_license_agreement: "true"
  register: nessus_download_uri

- debug:
    var: nessus_download_uri

- name: Cleanup local tmp download.
  local_action:
    module: file
    path: "{{ item }}"
    state: absent
  with_items:
    - "{{ nessus_linux_tmp }}/nessus_download.html"
  become: false
